<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Carles Hernandez-Ferrer ">
<meta name="description" content="This post is part of a series of 4. Here you have the links to each one:
 Building a Compiler in .Net (1 of 4) Building a Compiler in .Net (2 of 4) Building a Compiler in .Net (3 of 4) Building a Compiler in .Net (4 of 4)   Introduction In this second post we will implement the two first steps of a compiler: Scanner and Parser. Remember from part 1 a Scanner, also known as Lexical analyser, reads the characters from source code file and compose tokens." />
<meta name="keywords" content=", .net, C#" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://212.71.254.23/blog/building-a-compiler-in-net-2-of-4/" />


    <title>
        
            Building a Compiler in .Net  (2 of 4) :: Carles Hernandez-Ferrer 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.eaf4f2571fc0260b30532ce37bc0e1c2107885bfec3b592755f30dba7741301e.css">






<meta itemprop="name" content="Building a Compiler in .Net  (2 of 4)">
<meta itemprop="description" content="This post is part of a series of 4. Here you have the links to each one:
 Building a Compiler in .Net (1 of 4) Building a Compiler in .Net (2 of 4) Building a Compiler in .Net (3 of 4) Building a Compiler in .Net (4 of 4)   Introduction In this second post we will implement the two first steps of a compiler: Scanner and Parser. Remember from part 1 a Scanner, also known as Lexical analyser, reads the characters from source code file and compose tokens."><meta itemprop="datePublished" content="2012-01-25T00:00:00&#43;02:00" />
<meta itemprop="dateModified" content="2012-01-25T00:00:00&#43;02:00" />
<meta itemprop="wordCount" content="2475"><meta itemprop="image" content="http://212.71.254.23"/>
<meta itemprop="keywords" content=".net,C#," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://212.71.254.23"/>

<meta name="twitter:title" content="Building a Compiler in .Net  (2 of 4)"/>
<meta name="twitter:description" content="This post is part of a series of 4. Here you have the links to each one:
 Building a Compiler in .Net (1 of 4) Building a Compiler in .Net (2 of 4) Building a Compiler in .Net (3 of 4) Building a Compiler in .Net (4 of 4)   Introduction In this second post we will implement the two first steps of a compiler: Scanner and Parser. Remember from part 1 a Scanner, also known as Lexical analyser, reads the characters from source code file and compose tokens."/>








    <meta property="article:published_time" content="2012-01-25 00:00:00 &#43;0200 &#43;0200" />








    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">C:\carles.exe</span>
            <span class="logo__cursor" style=
                  "
                   background-color:#4169E1;
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about">About</a></li><li><a href="/academic">Academic</a></li><li><a href="/blog">Blog</a></li><li><a href="/fun">Fun</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="http://212.71.254.23/blog/building-a-compiler-in-net-2-of-4/">Building a Compiler in .Net  (2 of 4)</a></h2>

            
            
            

            <div class="post-content">
                <p>This post is part of a series of 4. Here you have the links to each one:</p>
<ul>
<li><a href="http://212.71.254.23/blog/building-a-compiler-in-net-1-of-4/">Building a Compiler in .Net (1 of 4)</a></li>
<li><a href="http://212.71.254.23/blog/building-a-compiler-in-net-2-of-4/">Building a Compiler in .Net (2 of 4)</a></li>
<li><a href="http://212.71.254.23/blog/building-a-compiler-in-net-3-of-4/">Building a Compiler in .Net (3 of 4)</a></li>
<li><a href="http://212.71.254.23/blog/building-a-compiler-in-net-4-of-4/">Building a Compiler in .Net (4 of 4)</a></li>
</ul>
<hr>
<h2 id="introduction">Introduction</h2>
<p>In this second post we will implement the two first steps of a compiler: Scanner and Parser. Remember from part 1 a Scanner, also known as Lexical analyser, reads the characters from source code file and compose tokens. This tokens will be taken by Parser (or Syntax Analyser) and will validate it&rsquo;s order using a grammar, generating the syntax-tree.</p>
<h3 id="very-simple-language">Very Simple Language</h3>
<p>It seems a good moment to write some lines about the language we will be able to compile. It&rsquo;s called <em>Very Simple Language</em> (VSL for friends). We will be able to declare variables without specifying it&rsquo;s type and make assignments, make conditional statements (<code>if-then-else</code>), loops (<code>while</code>), show information of screen (<code>print</code>) and read from console (<code>read_int</code> and <code>read_str</code>). As you can see we will not have functions or procedures, neither dynamic variable. I think it&rsquo;s the minimum expression of a &ldquo;hight-level programming language&rdquo;.</p>
<p>The grammar for <strong>VSL</strong> is:</p>
<pre><code>&lt; instr_stmt &gt; ::=
    | var &lt; identifier &gt; = &lt; expr_stmt &gt;
    | &lt; identifier &gt; = &lt; expr_stmt &gt;
    | read_int &lt; identifier &gt;
    | read_str &lt; identifier &gt;
    | print &lt; expr_stmt &gt;
    | &lt; instr_stmt &gt;; &lt; instr_stmt &gt;
    | if &lt; expr_stmt &gt; then &lt; instr_stmt &gt; { else &lt; instr_stmt &gt; } endif
    | while &lt; expr_stmt &gt; do &lt; instr_stmt &gt; endwhile

&lt; expr_stmt &gt; ::= &lt; bool_stmt &gt; { &lt; bool_op &gt; &lt; bool_stmt &gt; }

&lt; bool_op &gt; ::= == | &lt;&gt;
&lt; bool_stmt &gt; ::= &lt; term_stmt &gt; { &lt; term_op &gt; &lt; term_stmt &gt; }

&lt; term_op &gt; ::= + | -
&lt; term_stmt &gt; ::= &lt; factor_stmt &gt; { &lt; factor_op &gt; &lt; factor_stmt &gt; }

&lt; factor_op &gt; ::= * | /
&lt; factor_stmt &gt; ::=
    | &lt; variable &gt;
    | &lt; number_lt &gt;
    | &lt; string_lt &gt;
    | ( &lt; expr_stm &gt; )

&lt; variable &gt; ::= &lt; char &gt; &lt; ident_rest &gt;*
&lt; ident_rest &gt; ::= &lt; char &gt; | &lt; digit &gt;

&lt; number_lt &gt; ::= &lt; digit &gt;+
&lt; digit &gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

&lt; string_lt &gt; ::= &quot; &lt; string_elem &gt;* &quot;
&lt; string_elem &gt; ::= &lt; any char other than &quot; &gt;
</code></pre><p>Take care with the grammar. A good grammar will be longer than this one: Or numbers can&rsquo;t be negative, we haven&rsquo;t specified how big the numbers can be (32 bit integer?). A true and complete BNF grammar definition would precisely define all these details. By the way, in our VSLCompiler v0 this will be our grammar (If I have time, in the future, I will try to improve the grammar and the compiler for VSL).</p>
<p>Here we can see a sample of a VSL program:</p>
<pre><code>var times = 0;
print &quot;Type the number:&quot;;
read_int times;

var cnt = 0;
while cnt &lt;&gt; times do
    print &quot;lambda-function&quot;;
    cnt = cnt + 1;
endwhile;
</code></pre><h2 id="implementation">Implementation</h2>
<h3 id="scanner">Scanner</h3>
<p>The primary job of the Scanner is to break the input text in tokens. It&rsquo;s in charge to determinate which tokens will be sent to the Parser so it&rsquo;s able to throw out things that are not defined in the grammar (like tabs, comments,&hellip;).</p>
<p>So, at the end, we need to define with symbols will be interpreted as operands (in VSL case: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>==</code>, <code>&lt;&gt;</code>) or special operands (<code>(</code>, <code>)</code>, <code>;</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> tokens { Addition, Substraction, Division, Production, Assignment, Equating, Differentiation, LBracket, RBracket, Semicolon };
</code></pre></div><p>The Scanner implemented for VSL is as simple as the language. The structure of the class is the following one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Scanner</span> {

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> tokens { 
        Addition, Substraction, Division, Production, 
        Assignment, Equating, Differentiation,
        LBracket, RBracket, Semicolon 
    };

    <span style="color:#66d9ef">public</span> Collections.IList&lt;<span style="color:#66d9ef">object</span>&gt; Tokens {
        <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.result; }
    }

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> Scan( IO.TextReader p_input ) {
        <span style="color:#75715e">// TODO
</span><span style="color:#75715e"></span>    }
    &lt;/code&gt;&lt;/pre&gt;

}
</code></pre></div><p>With this structure we get an &ldquo;input text stream&rdquo; with a <code>TextReader</code> object and we will process it in <code>Scan</code> method. This method is, basically, a loop that walks over every character trying to recognise it according to the grammar. Every time a character is recognised a token will be formed and pushed into the tokens-list <code>result</code>. We assume that when we find a character <code>&quot;</code> it will encapsulate a string token.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> Scan( IO.TextReader p_input ) { 
    <span style="color:#66d9ef">while</span> ( p_input.Peek() != -<span style="color:#ae81ff">1</span> ) { 
        <span style="color:#66d9ef">char</span> read_ch = (<span style="color:#66d9ef">char</span>) p_input.Peek();
        <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">char</span>.IsWhiteSpace( read_ch ) ) {
            <span style="color:#75715e">// Skiping white spaces
</span><span style="color:#75715e"></span>            p_input.Read();
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">char</span>.IsLetter( read_ch ) || read_ch == <span style="color:#e6db74">&#39;_&#39;</span> ) {
            <span style="color:#75715e">// Reading an identifier
</span><span style="color:#75715e"></span>            Text.StringBuilder accum = <span style="color:#66d9ef">new</span> Text.StringBuilder();
            <span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">char</span>.IsLetter( read_ch ) || read_ch == <span style="color:#e6db74">&#39;_&#39;</span> ) {
                accum.Append( read_ch );
                p_input.Read();

                <span style="color:#66d9ef">if</span> ( p_input.Peek() == -<span style="color:#ae81ff">1</span> ) {
                    <span style="color:#66d9ef">break</span>;
                }

                read_ch = (<span style="color:#66d9ef">char</span>) p_input.Peek();
            }
            <span style="color:#66d9ef">this</span>.result.Add( accum.ToString() );
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;&#34;&#39;</span> ) {
            <span style="color:#75715e">// Reading a string literal
</span><span style="color:#75715e"></span>            Text.StringBuilder accum = <span style="color:#66d9ef">new</span> Text.StringBuilder();
            p_input.Read(); <span style="color:#75715e">// Skiping &#34;
</span><span style="color:#75715e"></span>
            <span style="color:#66d9ef">do</span> {
                <span style="color:#66d9ef">if</span> ( p_input.Peek() == -<span style="color:#ae81ff">1</span> ) {
                    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception(<span style="color:#e6db74">&#34;Unterminated string literal.&#34;</span>);
                }
                read_ch = (<span style="color:#66d9ef">char</span>) p_input.Peek();
                <span style="color:#66d9ef">if</span> ( read_ch != <span style="color:#e6db74">&#39;&#34;&#39;</span> ) {
                    accum.Append( read_ch );
                    p_input.Read();
                }
            } <span style="color:#66d9ef">while</span> ( read_ch != <span style="color:#e6db74">&#39;&#34;&#39;</span> );
            p_input.Read();
            <span style="color:#66d9ef">this</span>.result.Add( accum ); <span style="color:#75715e">// NO .ToString(). We will use type TextBuffer in Parser.
</span><span style="color:#75715e"></span>        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">char</span>.IsDigit( read_ch ) ) {
            <span style="color:#75715e">// Reading a numeric literal
</span><span style="color:#75715e"></span>            Text.StringBuilder accum = <span style="color:#66d9ef">new</span> Text.StringBuilder();
            <span style="color:#66d9ef">bool</span> is_float = <span style="color:#66d9ef">false</span>;
            <span style="color:#66d9ef">while</span>( <span style="color:#66d9ef">char</span>.IsDigit( read_ch ) || ( read_ch == <span style="color:#e6db74">&#39;.&#39;</span> ) ) {
                accum.Append( read_ch );
                p_input.Read();

                <span style="color:#66d9ef">if</span> ( p_input.Peek() == -<span style="color:#ae81ff">1</span> ) {
                    <span style="color:#66d9ef">break</span>;
                }

                <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;.&#39;</span> ) {
                    is_float = <span style="color:#66d9ef">true</span>;
                }

                read_ch = (<span style="color:#66d9ef">char</span>) p_input.Peek();
            }

            <span style="color:#66d9ef">if</span> ( is_float ) {
                <span style="color:#66d9ef">this</span>.result.Add( <span style="color:#66d9ef">float</span>.Parse( accum.ToString() ) );
            }
            <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">this</span>.result.Add( <span style="color:#66d9ef">int</span>.Parse( accum.ToString() ) );
            }
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;+&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Addition );
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;-&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Substraction );
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;*&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Production );
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;/&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Division );
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;=&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">if</span> ( ( p_input.Peek() != -<span style="color:#ae81ff">1</span> ) &amp;&amp; ( p_input.Peek() == <span style="color:#e6db74">&#39;=&#39;</span> ) ) {
                p_input.Read();
                <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Equating );
            }
            <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Assignment );
            }
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;&lt;&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">if</span> ( ( p_input.Peek() == -<span style="color:#ae81ff">1</span> ) || ( p_input.Peek() != <span style="color:#e6db74">&#39;&gt;&#39;</span> ) ) {
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception(<span style="color:#e6db74">&#34;Unterminated operation literal.&#34;</span>);
            }
            <span style="color:#66d9ef">else</span> {
                p_input.Read();
                <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Differentiation );
            }
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;;&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.Semicolon );
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;(&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">if</span> ( ( p_input.Peek() != -<span style="color:#ae81ff">1</span> ) &amp;&amp; ( p_input.Peek() == <span style="color:#e6db74">&#39;*&#39;</span> ) ) {
                p_input.Read();
                <span style="color:#66d9ef">bool</span> end_comm = <span style="color:#66d9ef">false</span>;
                <span style="color:#66d9ef">do</span> {
                    <span style="color:#66d9ef">if</span> ( p_input.Peek() == -<span style="color:#ae81ff">1</span> ) {
                        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception(<span style="color:#e6db74">&#34;Unterminated comment.&#34;</span>);
                    }
                    read_ch = (<span style="color:#66d9ef">char</span>) p_input.Peek();
                    p_input.Read();
                    <span style="color:#66d9ef">if</span> ( ( read_ch == <span style="color:#e6db74">&#39;*&#39;</span> ) &amp;&amp; (p_input.Peek() == <span style="color:#e6db74">&#39;)&#39;</span>) ) {
                        p_input.Read();
                        end_comm = <span style="color:#66d9ef">true</span>;
                    }
                } <span style="color:#66d9ef">while</span> ( !end_comm );
                p_input.Read();
            }
            <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.LBracket );
                <span style="color:#66d9ef">if</span> ( p_input.Peek() == -<span style="color:#ae81ff">1</span> ) {
                    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception(<span style="color:#e6db74">&#34;Unterminated operation.&#34;</span>);
                }
            }
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( read_ch == <span style="color:#e6db74">&#39;)&#39;</span> ) {
            p_input.Read();
            <span style="color:#66d9ef">this</span>.result.Add( Scanner.tokens.RBracket );
        }
    }
}
</code></pre></div><p>At this point we have all the tokens in <code>result</code>, ready to be sent to Parser.</p>
<h3 id="parser">Parser</h3>
<p>The Parser developed for Very Simple Language has a umber of jobs: The main one is to ensure source program conforms to the grammar specification (if not it raises an error). It also creates the syntax-tree, the unique representation of the source code, consumed by Code Generator, and figures out what runtime types to use.</p>
<p>On the first hand we are going to take a look the the syntax-tree structure. In my mind I have developed the syntax-tree as a instanced-class tree, lets see:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InstrStmt</span> { }

<span style="color:#75715e">// var &lt; identifier &gt; = &lt; expr_stmt &gt; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VarStmt</span> : InstrStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Identifier; <span style="color:#66d9ef">public</span> ExprStmt Expression; }

<span style="color:#75715e">// &lt; identifier &gt; =  
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AssignStmt</span> : InstrStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Identifier; <span style="color:#66d9ef">public</span> ExprStmt Expression; }

<span style="color:#75715e">// read_int &lt; identifier &gt; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReadIntStmt</span> : InstrStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Identifier; }

<span style="color:#75715e">// read_str &lt; identifier &gt; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReadStrStmt</span> : InstrStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Identifier; }

<span style="color:#75715e">// print &lt; expr_stmt &gt; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PrintStmt</span> : InstrStmt { <span style="color:#66d9ef">public</span> ExprStmt Expression; }

<span style="color:#75715e">// &lt; instr_stmt &gt;; &lt; instr_stmt &gt; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sequence</span> : InstrStmt { <span style="color:#66d9ef">public</span> InstrStmt First; <span style="color:#66d9ef">public</span> InstrStmt Second; }

<span style="color:#75715e">// if &lt; expr_stmt &gt; then &lt; instr_stmt &gt; { else &lt; instr_stmt &gt; } endif 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IfStmt</span> : InstrStmt { <span style="color:#66d9ef">public</span> ExprStmt Condition; <span style="color:#66d9ef">public</span> InstrStmt If_Body; <span style="color:#66d9ef">public</span> InstrStmt Else_Body; }

<span style="color:#75715e">// while &lt; expr_stmt &gt; do &lt; instr_stmt &gt; endwhile 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WhileStmt</span> : InstrStmt { <span style="color:#66d9ef">public</span> ExprStmt Condition; <span style="color:#66d9ef">public</span> InstrStmt While_Body; }

<span style="color:#75715e">// &lt; expr_stmt &gt; = &lt; bool_stmt &gt; {&lt; bool_op &gt; &lt; bool_stmt &gt; } 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExprStmt</span> { <span style="color:#66d9ef">public</span> BoolStmt Right; <span style="color:#66d9ef">public</span> BoolStmt Left; <span style="color:#66d9ef">public</span> BoolOp Op; }

<span style="color:#75715e">// &lt; bool_op &gt; ::= == | &lt;&gt; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> BoolOp { Equating, Differentiation };

<span style="color:#75715e">// &lt; bool_stmt &gt; ::= &lt; term_stmt &gt; { &lt; term_op &gt; &lt; term_stmt &gt; } 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BoolStmt</span> { <span style="color:#66d9ef">public</span> TermStmt Right; <span style="color:#66d9ef">public</span> TermStmt Left; <span style="color:#66d9ef">public</span> TermOp Op; }

<span style="color:#75715e">// &lt; term_op &gt; := + | - 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> TermOp { Addition, Substraction };

<span style="color:#75715e">// &lt; term_stmt &gt; ::= &lt; factor_stmt &gt; { &lt; factor_op &gt; &lt; factor_stmt &gt; } 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TermStmt</span> { <span style="color:#66d9ef">public</span> FactorStmt Right; <span style="color:#66d9ef">public</span> FactorStmt Left; <span style="color:#66d9ef">public</span> FactorOp Op; }

<span style="color:#75715e">// &lt; factor_op &gt; ::= * | / 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> FactorOp { Division, Production };

<span style="color:#75715e">// &lt; factor_stmt &gt; ::= &lt; identifier &gt; // | &lt; number &gt; // | &lt; string &gt; // | ( &lt; expr_stm &gt; ) 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FactorStmt</span> { }

<span style="color:#75715e">// &lt; string &gt; ::= &#34; &lt; string_elem &gt;* &#34; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringLt</span> : FactorStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Value; }

<span style="color:#75715e">// &lt; int &gt; ::= &lt; digit &gt;+ 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IntLt</span> : FactorStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Value; }

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FloatLt</span> : FactorStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> Value; }

<span style="color:#75715e">// &lt; ident &gt; ::= &lt; char &gt; &lt; ident_rest &gt;* // &lt; ident_rest &gt; ::= &lt; char &gt; | &lt; digit &gt; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Variable</span> : FactorStmt { <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Identifier; }

<span style="color:#75715e">// ( &lt; expr_stm &gt; ) 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BracketExpr</span> : FactorStmt { <span style="color:#66d9ef">public</span> ExprStmt Expression; }
</code></pre></div><p>I prefer to think syntax-tree keeps the structure of the source code according to the language&rsquo;s grammar. Sure you can find a different way to implement the syntax-tree (may be an abstract syntax-tree).</p>
<p>There are many algorithms available for parsing implementation. The definition of our grammar implies we will use a LL strategy (Left-to-right, Left-most derivation) and a top-down parser (for more information you can see LR, and bottom-up grammars). At the end, LL, simple means that it reads text from left to down, building the syntax-tree based on the next available token.</p>
<p>The constructor for my Parser class is as simply as Scanner ones. It takes a list of tokens that was created by the scanner:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span> {

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> index;
    <span style="color:#66d9ef">private</span> Collections.IList&lt;<span style="color:#66d9ef">object</span>&gt; tokens;
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> InstrStmt result;

    <span style="color:#66d9ef">public</span> Parser ( Collections.IList&lt;<span style="color:#66d9ef">object</span>&gt; p_tokens ) {
        <span style="color:#66d9ef">this</span>.tokens = p_tokens;
        <span style="color:#66d9ef">this</span>.index = <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">this</span>.result = <span style="color:#66d9ef">this</span>.ParseInstr();

        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.index != <span style="color:#66d9ef">this</span>.tokens.Count) {
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception(<span style="color:#e6db74">&#34;Expected EOF&#34;</span>);
        }
    }

    <span style="color:#66d9ef">public</span> InstrStmt Result {
        <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> result; }
    }

    <span style="color:#66d9ef">private</span> InstrStmt ParseInstr() {
        <span style="color:#75715e">// TODO
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">private</span> ExprStmt ParseExpr() {
        <span style="color:#75715e">// TODO
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">private</span> BoolStmt ParseBool() {
        <span style="color:#75715e">// TODO
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">private</span> TermStmt ParseTerm() {
        <span style="color:#75715e">// TODO
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">private</span> FactorStmt ParseFctr() {
        <span style="color:#75715e">// TODO
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>The core of the parsing work is done by <code>ParseInstr</code> method. As we can see in the code before it returns a <code>InstrStmt</code> node (which serves as a root node of the syntax-tree). The Parser traverses the list of tokens using an index as the current position. For each token it tries to assign to an &ldquo;Instruction case&rdquo;, in other case it raises an error. In each &ldquo;instruction case&rdquo; the <code>ParseInstr</code> will analyses the statement using the other Parsing methods (<code>ParseExprs</code>, <code>ParseBool</code>, <code>ParseTerm</code>, <code>ParseFactr</code>).</p>
<p>We are going to see an example of ParseInstr: <code>print 3;</code>.</p>
<p>Firstly we see the <code>ParseIntr</code> statement to parse this order:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( <span style="color:#e6db74">&#34;print&#34;</span> ) ) { 
    <span style="color:#66d9ef">this</span>.index++; 
    PrintStmt print_ = <span style="color:#66d9ef">new</span> PrintStmt(); 
    print_.Expression = <span style="color:#66d9ef">this</span>.ParseExpr(); 
    result = print_; 
}
</code></pre></div><p>The <code>print</code> token is discarded and we call <code>ParseExpr</code> to obtain the expression needed after the token <code>print</code> (grammar rules). We follow the call-list until <code>ParseFactr</code>. The implementation of <code>ParseFactr</code> is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> FactorStmt ParseFctr() { 
    <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span>.index == <span style="color:#66d9ef">this</span>.tokens.Count ) { 
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception( <span style="color:#e6db74">&#34;Expected statement, got EOF.&#34;</span> ); 
    }

    <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ] <span style="color:#66d9ef">is</span> Text.StringBuilder ) {
        <span style="color:#66d9ef">string</span> strValue = ( (Text.StringBuilder) <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index++ ] ).ToString();
        StringLt stringLiteral = <span style="color:#66d9ef">new</span> StringLt();
        stringLiteral.Value = strValue;
        <span style="color:#66d9ef">return</span> stringLiteral;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ] <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">int</span> ) {
        <span style="color:#66d9ef">int</span> intValue = (<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index++ ];
        IntLt intLiteral = <span style="color:#66d9ef">new</span> IntLt();
        intLiteral.Value = intValue;
        <span style="color:#66d9ef">return</span> intLiteral;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ] <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">float</span> ) {
        <span style="color:#66d9ef">float</span> floatValue = (<span style="color:#66d9ef">float</span>) <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index++ ];
        FloatLt floatLiteral = <span style="color:#66d9ef">new</span> FloatLt();
        floatLiteral.Value = floatValue;
        <span style="color:#66d9ef">return</span> floatLiteral;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ] <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">string</span> ) {
        <span style="color:#66d9ef">string</span> identifier = (<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index++ ];
        Variable variable = <span style="color:#66d9ef">new</span> Variable();
        variable.Identifier = identifier;
        <span style="color:#66d9ef">return</span> variable;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( Scanner.tokens.LBracket ) ) {
        <span style="color:#66d9ef">this</span>.index++; <span style="color:#75715e">// LBracket
</span><span style="color:#75715e"></span>        BracketExpr expr = <span style="color:#66d9ef">new</span> BracketExpr();
        expr.Expression = <span style="color:#66d9ef">this</span>.ParseExpr();
        <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( Scanner.tokens.RBracket ) ) {
            <span style="color:#66d9ef">this</span>.index++; <span style="color:#75715e">// RBracket
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> expr;
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception( <span style="color:#e6db74">&#34;Expected &#34;</span>right bracket<span style="color:#e6db74">&#34; after &#34;</span>left bracket<span style="color:#e6db74">&#34; and &#34;</span>expression<span style="color:#e6db74">&#34;.&#34;</span> );
        }
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception( <span style="color:#e6db74">&#34;Expected &#34;</span><span style="color:#66d9ef">string</span> literal<span style="color:#e6db74">&#34;, &#34;</span><span style="color:#66d9ef">int</span> literal<span style="color:#e6db74">&#34;, &#34;</span><span style="color:#66d9ef">float</span> literal<span style="color:#e6db74">&#34;, or variable.&#34;</span> );
    }
}
</code></pre></div><p>Here, at the lowest level of the parsing function we define with is the operand of each operation. In this case we return a int literal.</p>
<p>Consecutive instructions are allows using the &ldquo;Squence token&rdquo;, implemented in <code>ParseInstr</code> as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">this</span>.index &lt; <span style="color:#66d9ef">this</span>.tokens.Count &amp;&amp; <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( Scanner.tokens.Semicolon ) ) {

    <span style="color:#66d9ef">this</span>.index++;

    <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">this</span>.index &lt; <span style="color:#66d9ef">this</span>.tokens.Count &amp;&amp; !<span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( <span style="color:#e6db74">&#34;else&#34;</span> ) &amp;&amp;
            !<span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( <span style="color:#e6db74">&#34;endif&#34;</span> ) &amp;&amp; !<span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( <span style="color:#e6db74">&#34;endwhile&#34;</span> ) ) {
        Sequence sqc = <span style="color:#66d9ef">new</span> Sequence();
        sqc.First = result;
        sqc.Second = <span style="color:#66d9ef">this</span>.ParseInstr();
        result = sqc;
    }
    
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( !<span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index ].Equals( Scanner.tokens.Semicolon ) ) { 
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> System.Exception(<span style="color:#e6db74">&#34;Expected &#34;</span>semicolon<span style="color:#e6db74">&#34; after token &#34;</span> + <span style="color:#66d9ef">this</span>.tokens[ <span style="color:#66d9ef">this</span>.index-<span style="color:#ae81ff">1</span> ].ToString()); 
    } 
</code></pre></div><p>This sequence node contains two pointers to <code>InstrStmt</code> nodes and forms the basis of the syntax-tree structure.</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
            
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="http://212.71.254.23/tags/.net/">.net</a></span>
        <span class="tag"><a href="http://212.71.254.23/tags/c/">C#</a></span>
        
    </p>

            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            <span><a href="http://212.71.254.23">Carles Hernandez-Ferrer</a></span>
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span><span><a href="http://212.71.254.23/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
          </div>
    </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.599099f1f14b78b657d524b28e10e0c5098e7cd46e9c7aed73d577068a276c3ff1bb234cbf29cb313333e83cf411727b43157c91ce5b809e2ffc81664614608e.js" integrity="sha512-WZCZ8fFLeLZX1SSyjhDgxQmOfNRunHrtc9V3BoonbD/xuyNMvynLMTMz6Dz0EXJ7QxV8kc5bgJ4v/IFmRhRgjg=="></script>



    </body>
</html>
